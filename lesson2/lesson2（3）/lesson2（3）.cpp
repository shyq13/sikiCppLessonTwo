#include <iostream>
// 运行该项目时一定要将它设为启动项！！！
// 运行该项目时一定要将它设为启动项！！！
// 运行该项目时一定要将它设为启动项！！！
using namespace std;

int reset(int i);
void reset1(int* p);

int main() {
    // 参数传递
    // 形参与实参
    // 形参的类型决定了形参和实参的交互方式。
    // 如果形参是引用类型，它将绑定到对应的实参上（传引用参数)； 
    // 否则，将实参的值拷贝后赋给形参（传值参数）
    // 1. 传值参数
    // 传值方法
    /*
     传值参数有2种方式：
         1.将实参的实际值复制给函数的形参。在这种情况下，修改函数内的形参对实参没有影响
         2.将参数的地址复制给形参（指针）
         因为指针使我们可以间接地访问它所指的对象，所以通过指针可以修改它所指对象的值
    */
    // 见reset、reset1函数内

    // reset、reset1的使用
    int a = 10;
    cout << "a * 2 = " << reset(a) << endl;
    // 由于reset有返回值，所以可以直接输出

    cout << "使用reset函数后a是" << a << endl;
    // 由于reset函数使用的是实参拷贝给形参，使用形参运算，所以实参的值不变

    reset1(&a);
    cout << "a * 2 = " << a << endl;
    // 由于reset1没有返回值，所以会直接赋值给a，需要先运行函数再输出a
    // 输出结果
    // （1）a * 2 = 20（a还是10）
    // （2）a * 2 = 20（a变成了20）

    cout << "使用reset1后a变成了" << a << endl;
    // 由于reset1函数使用的是直接改变实参的值，所以实参的值变成了20
    // 输出结果：使用reset1后a变成了20

    cout << '\n'
        << "------------------------------------------------------------"
        << endl << '\n';

    reset1(&a);
    cout << "调用reset1函数后，实参a的地址是" << &a << endl;

    return 0;
}

int reset(int i) {
    i *= 2;
    return i;
    // 传递实参的实际值，将实参的值拷贝给形参，函数体重修改的是形参
}

void reset1(int* p) {    // 用于修改reset参数的值（使用指针）
    *p *= 2;
    static int count = 0;
    // 传递实参的地址，修改*p的值（相当于修改实参对应的对象的值）
    
    count++;
    if (count >= 2) {
        p = 0;   // 但如果修改的是p的值，那么修改的是形参的地址，而非实参的地址
        cout << "调用reset1函数后，形参p的地址变成了" << p << endl;
    }
    // 但是改变了p的地址后，就不能修改实参的值了
    // 如果修改了p的地址，再修改实参的值就会报错
}
// 使用这两个函数都能修改变量的值